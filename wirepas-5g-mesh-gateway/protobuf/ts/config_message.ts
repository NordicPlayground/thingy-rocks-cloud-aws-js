/* eslint-disable */
// @generated by protobuf-ts 2.8.2 with parameter ts_nocheck,eslint_disable
// @generated from protobuf file "config_message.proto" (package "wirepas.proto.gateway_api", syntax proto2)
// tslint:disable
// @ts-nocheck
import type {
	BinaryReadOptions,
	BinaryWriteOptions,
	IBinaryReader,
	IBinaryWriter,
	PartialMessage,
} from '@protobuf-ts/runtime'
import {
	MESSAGE_TYPE,
	MessageType,
	UnknownFieldHandler,
	WireType,
	reflectionMergePartial,
} from '@protobuf-ts/runtime'
import {
	EventHeader,
	FirmwareVersion,
	OnOffState,
	RequestHeader,
	ResponseHeader,
} from './wp_global.js'
/**
 * @generated from protobuf message wirepas.proto.gateway_api.NodeRole
 */
export interface NodeRole {
	/**
	 * @generated from protobuf field: wirepas.proto.gateway_api.NodeRole.BaseRole role = 1;
	 */
	role: NodeRole_BaseRole
	/**
	 * @generated from protobuf field: repeated wirepas.proto.gateway_api.NodeRole.RoleFlags flags = 2;
	 */
	flags: NodeRole_RoleFlags[]
}
/**
 * @generated from protobuf enum wirepas.proto.gateway_api.NodeRole.BaseRole
 */
export enum NodeRole_BaseRole {
	/**
	 * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
	 */
	UNSPECIFIED$ = 0,
	/**
	 * @generated from protobuf enum value: SINK = 1;
	 */
	SINK = 1,
	/**
	 * @generated from protobuf enum value: ROUTER = 2;
	 */
	ROUTER = 2,
	/**
	 * @generated from protobuf enum value: NON_ROUTER = 3;
	 */
	NON_ROUTER = 3,
}
/**
 * @generated from protobuf enum wirepas.proto.gateway_api.NodeRole.RoleFlags
 */
export enum NodeRole_RoleFlags {
	/**
	 * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
	 */
	UNSPECIFIED$ = 0,
	/**
	 * @generated from protobuf enum value: LOW_LATENCY = 1;
	 */
	LOW_LATENCY = 1,
	/**
	 * @generated from protobuf enum value: AUTOROLE = 2;
	 */
	AUTOROLE = 2,
}
/**
 * @generated from protobuf message wirepas.proto.gateway_api.AccessCycleRange
 */
export interface AccessCycleRange {
	/**
	 * @generated from protobuf field: uint32 min_ms = 1;
	 */
	minMs: number
	/**
	 * @generated from protobuf field: uint32 max_ms = 2;
	 */
	maxMs: number
}
/**
 * @generated from protobuf message wirepas.proto.gateway_api.ChannelRange
 */
export interface ChannelRange {
	/**
	 * @generated from protobuf field: uint32 min_channel = 1;
	 */
	minChannel: number
	/**
	 * @generated from protobuf field: uint32 max_channel = 2;
	 */
	maxChannel: number
}
/**
 * @generated from protobuf message wirepas.proto.gateway_api.AppConfigData
 */
export interface AppConfigData {
	/**
	 * @generated from protobuf field: uint32 diag_interval_s = 1;
	 */
	diagIntervalS: number // Diagnostics interval in seconds
	/**
	 * @generated from protobuf field: bytes app_config_data = 2;
	 */
	appConfigData: Uint8Array // App config data
	/**
	 * @generated from protobuf field: uint32 seq = 3;
	 */
	seq: number
}
/**
 * @generated from protobuf message wirepas.proto.gateway_api.NetworkKeys
 */
export interface NetworkKeys {
	/**
	 * @generated from protobuf field: bytes cipher = 1;
	 */
	cipher: Uint8Array
	/**
	 * @generated from protobuf field: bytes authentication = 2;
	 */
	authentication: Uint8Array
}
/**
 * @generated from protobuf message wirepas.proto.gateway_api.SinkReadConfig
 */
export interface SinkReadConfig {
	/**
	 * Local id to uniquely identify a sink on gateway
	 *
	 * @generated from protobuf field: string sink_id = 1;
	 */
	sinkId: string
	/**
	 * Sink minimal config
	 *
	 * @generated from protobuf field: optional wirepas.proto.gateway_api.NodeRole node_role = 2;
	 */
	nodeRole?: NodeRole
	/**
	 * @generated from protobuf field: optional uint32 node_address = 3;
	 */
	nodeAddress?: number
	/**
	 * @generated from protobuf field: optional uint64 network_address = 4;
	 */
	networkAddress?: bigint
	/**
	 * @generated from protobuf field: optional uint32 network_channel = 5;
	 */
	networkChannel?: number
	/**
	 * @generated from protobuf field: optional wirepas.proto.gateway_api.AppConfigData app_config = 6;
	 */
	appConfig?: AppConfigData
	/**
	 * @generated from protobuf field: optional uint32 channel_map = 7;
	 */
	channelMap?: number
	/**
	 * @generated from protobuf field: optional bool are_keys_set = 8;
	 */
	areKeysSet?: boolean
	/**
	 * @generated from protobuf field: optional wirepas.proto.gateway_api.AccessCycleRange current_ac_range = 9;
	 */
	currentAcRange?: AccessCycleRange
	/**
	 * Read only parameters
	 *
	 * @generated from protobuf field: optional wirepas.proto.gateway_api.AccessCycleRange ac_limits = 10;
	 */
	acLimits?: AccessCycleRange
	/**
	 * @generated from protobuf field: optional uint32 max_mtu = 11;
	 */
	maxMtu?: number
	/**
	 * @generated from protobuf field: optional wirepas.proto.gateway_api.ChannelRange channel_limits = 12;
	 */
	channelLimits?: ChannelRange
	/**
	 * @generated from protobuf field: optional uint32 hw_magic = 13;
	 */
	hwMagic?: number
	/**
	 * @generated from protobuf field: optional uint32 stack_profile = 14;
	 */
	stackProfile?: number
	/**
	 * @generated from protobuf field: optional uint32 app_config_max_size = 15;
	 */
	appConfigMaxSize?: number
	/**
	 * @generated from protobuf field: optional wirepas.proto.gateway_api.FirmwareVersion firmware_version = 16;
	 */
	firmwareVersion?: FirmwareVersion
	/**
	 * State of sink
	 *
	 * @generated from protobuf field: optional wirepas.proto.gateway_api.OnOffState sink_state = 17;
	 */
	sinkState?: OnOffState
}
/**
 * @generated from protobuf message wirepas.proto.gateway_api.SinkNewConfig
 */
export interface SinkNewConfig {
	/**
	 * Local id to uniquely identify a sink on gateway
	 *
	 * @generated from protobuf field: string sink_id = 1;
	 */
	sinkId: string
	/**
	 * Node minimal config
	 *
	 * @generated from protobuf field: optional wirepas.proto.gateway_api.NodeRole node_role = 2;
	 */
	nodeRole?: NodeRole
	/**
	 * @generated from protobuf field: optional uint32 node_address = 3;
	 */
	nodeAddress?: number
	/**
	 * @generated from protobuf field: optional uint64 network_address = 4;
	 */
	networkAddress?: bigint
	/**
	 * @generated from protobuf field: optional uint32 network_channel = 5;
	 */
	networkChannel?: number
	/**
	 * @generated from protobuf field: optional wirepas.proto.gateway_api.AppConfigData app_config = 6;
	 */
	appConfig?: AppConfigData
	/**
	 * @generated from protobuf field: optional uint32 channel_map = 7;
	 */
	channelMap?: number
	/**
	 * @generated from protobuf field: optional wirepas.proto.gateway_api.NetworkKeys keys = 8;
	 */
	keys?: NetworkKeys
	/**
	 * @generated from protobuf field: optional wirepas.proto.gateway_api.AccessCycleRange current_ac_range = 9;
	 */
	currentAcRange?: AccessCycleRange
	/**
	 * State of sink
	 *
	 * @generated from protobuf field: optional wirepas.proto.gateway_api.OnOffState sink_state = 10;
	 */
	sinkState?: OnOffState
}
/**
 * @generated from protobuf message wirepas.proto.gateway_api.GatewayInfo
 */
export interface GatewayInfo {
	/**
	 * Current timestamp when GatewayInfo is generated
	 * It is a unix timestamp in s since epoch
	 *
	 * @generated from protobuf field: uint64 current_time_s_epoch = 1;
	 */
	currentTimeSEpoch: bigint
	/**
	 * Optional gateway name (gateway manufacturer specific)
	 *
	 * @generated from protobuf field: optional string gw_model = 2;
	 */
	gwModel?: string
	/**
	 * Optional gateway version (gateway manufacturer specific)
	 *
	 * @generated from protobuf field: optional string gw_version = 3;
	 */
	gwVersion?: string
	/**
	 * API version implemented in the gateway
	 * This field must be explicitely set from code and must be
	 * the one defined in each released verion.
	 * Current version is 1
	 *
	 * @generated from protobuf field: optional uint32 implemented_api_version = 4;
	 */
	implementedApiVersion?: number
}
/**
 *
 * Commands definition
 *
 * @generated from protobuf message wirepas.proto.gateway_api.StatusEvent
 */
export interface StatusEvent {
	/**
	 * @generated from protobuf field: wirepas.proto.gateway_api.EventHeader header = 1;
	 */
	header?: EventHeader
	/**
	 * @generated from protobuf field: uint32 version = 2;
	 */
	version: number
	/**
	 * @generated from protobuf field: wirepas.proto.gateway_api.OnOffState state = 3;
	 */
	state: OnOffState
}
/**
 * @generated from protobuf message wirepas.proto.gateway_api.GetConfigsReq
 */
export interface GetConfigsReq {
	/**
	 * @generated from protobuf field: wirepas.proto.gateway_api.RequestHeader header = 1;
	 */
	header?: RequestHeader
}
/**
 * @generated from protobuf message wirepas.proto.gateway_api.GetConfigsResp
 */
export interface GetConfigsResp {
	/**
	 * @generated from protobuf field: wirepas.proto.gateway_api.ResponseHeader header = 1;
	 */
	header?: ResponseHeader
	/**
	 * @generated from protobuf field: repeated wirepas.proto.gateway_api.SinkReadConfig configs = 2;
	 */
	configs: SinkReadConfig[] // Gateway may have multiple sinks
}
/**
 * @generated from protobuf message wirepas.proto.gateway_api.SetConfigReq
 */
export interface SetConfigReq {
	/**
	 * @generated from protobuf field: wirepas.proto.gateway_api.RequestHeader header = 1;
	 */
	header?: RequestHeader
	/**
	 * @generated from protobuf field: wirepas.proto.gateway_api.SinkNewConfig config = 2;
	 */
	config?: SinkNewConfig
}
/**
 * @generated from protobuf message wirepas.proto.gateway_api.SetConfigResp
 */
export interface SetConfigResp {
	/**
	 * @generated from protobuf field: wirepas.proto.gateway_api.ResponseHeader header = 1;
	 */
	header?: ResponseHeader
	/**
	 * Send back the current config
	 *
	 * @generated from protobuf field: wirepas.proto.gateway_api.SinkReadConfig config = 2;
	 */
	config?: SinkReadConfig
}
/**
 * @generated from protobuf message wirepas.proto.gateway_api.GetGwInfoReq
 */
export interface GetGwInfoReq {
	/**
	 * @generated from protobuf field: wirepas.proto.gateway_api.RequestHeader header = 1;
	 */
	header?: RequestHeader
}
/**
 * @generated from protobuf message wirepas.proto.gateway_api.GetGwInfoResp
 */
export interface GetGwInfoResp {
	/**
	 * @generated from protobuf field: wirepas.proto.gateway_api.ResponseHeader header = 1;
	 */
	header?: ResponseHeader
	/**
	 * @generated from protobuf field: wirepas.proto.gateway_api.GatewayInfo info = 2;
	 */
	info?: GatewayInfo
}
// @generated message type with reflection information, may provide speed optimized methods
class NodeRole$Type extends MessageType<NodeRole> {
	constructor() {
		super('wirepas.proto.gateway_api.NodeRole', [
			{
				no: 1,
				name: 'role',
				kind: 'enum',
				T: () => [
					'wirepas.proto.gateway_api.NodeRole.BaseRole',
					NodeRole_BaseRole,
				],
			},
			{
				no: 2,
				name: 'flags',
				kind: 'enum',
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: () => [
					'wirepas.proto.gateway_api.NodeRole.RoleFlags',
					NodeRole_RoleFlags,
				],
				options: { nanopb: { maxCount: 16 } },
			},
		])
	}
	create(value?: PartialMessage<NodeRole>): NodeRole {
		const message = { role: 0, flags: [] }
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
			enumerable: false,
			value: this,
		})
		if (value !== undefined)
			reflectionMergePartial<NodeRole>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: NodeRole,
	): NodeRole {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* wirepas.proto.gateway_api.NodeRole.BaseRole role */ 1:
					message.role = reader.int32()
					break
				case /* repeated wirepas.proto.gateway_api.NodeRole.RoleFlags flags */ 2:
					if (wireType === WireType.LengthDelimited)
						for (let e = reader.int32() + reader.pos; reader.pos < e; )
							message.flags.push(reader.int32())
					else message.flags.push(reader.int32())
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d,
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: NodeRole,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* wirepas.proto.gateway_api.NodeRole.BaseRole role = 1; */
		if (message.role !== 0) writer.tag(1, WireType.Varint).int32(message.role)
		/* repeated wirepas.proto.gateway_api.NodeRole.RoleFlags flags = 2; */
		for (let i = 0; i < message.flags.length; i++)
			writer.tag(2, WireType.Varint).int32(message.flags[i])
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer,
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message wirepas.proto.gateway_api.NodeRole
 */
export const NodeRole = new NodeRole$Type()
// @generated message type with reflection information, may provide speed optimized methods
class AccessCycleRange$Type extends MessageType<AccessCycleRange> {
	constructor() {
		super('wirepas.proto.gateway_api.AccessCycleRange', [
			{ no: 1, name: 'min_ms', kind: 'scalar', T: 13 /*ScalarType.UINT32*/ },
			{ no: 2, name: 'max_ms', kind: 'scalar', T: 13 /*ScalarType.UINT32*/ },
		])
	}
	create(value?: PartialMessage<AccessCycleRange>): AccessCycleRange {
		const message = { minMs: 0, maxMs: 0 }
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
			enumerable: false,
			value: this,
		})
		if (value !== undefined)
			reflectionMergePartial<AccessCycleRange>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: AccessCycleRange,
	): AccessCycleRange {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* uint32 min_ms */ 1:
					message.minMs = reader.uint32()
					break
				case /* uint32 max_ms */ 2:
					message.maxMs = reader.uint32()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d,
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: AccessCycleRange,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* uint32 min_ms = 1; */
		if (message.minMs !== 0)
			writer.tag(1, WireType.Varint).uint32(message.minMs)
		/* uint32 max_ms = 2; */
		if (message.maxMs !== 0)
			writer.tag(2, WireType.Varint).uint32(message.maxMs)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer,
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message wirepas.proto.gateway_api.AccessCycleRange
 */
export const AccessCycleRange = new AccessCycleRange$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ChannelRange$Type extends MessageType<ChannelRange> {
	constructor() {
		super('wirepas.proto.gateway_api.ChannelRange', [
			{
				no: 1,
				name: 'min_channel',
				kind: 'scalar',
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 2,
				name: 'max_channel',
				kind: 'scalar',
				T: 13 /*ScalarType.UINT32*/,
			},
		])
	}
	create(value?: PartialMessage<ChannelRange>): ChannelRange {
		const message = { minChannel: 0, maxChannel: 0 }
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
			enumerable: false,
			value: this,
		})
		if (value !== undefined)
			reflectionMergePartial<ChannelRange>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: ChannelRange,
	): ChannelRange {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* uint32 min_channel */ 1:
					message.minChannel = reader.uint32()
					break
				case /* uint32 max_channel */ 2:
					message.maxChannel = reader.uint32()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d,
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: ChannelRange,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* uint32 min_channel = 1; */
		if (message.minChannel !== 0)
			writer.tag(1, WireType.Varint).uint32(message.minChannel)
		/* uint32 max_channel = 2; */
		if (message.maxChannel !== 0)
			writer.tag(2, WireType.Varint).uint32(message.maxChannel)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer,
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message wirepas.proto.gateway_api.ChannelRange
 */
export const ChannelRange = new ChannelRange$Type()
// @generated message type with reflection information, may provide speed optimized methods
class AppConfigData$Type extends MessageType<AppConfigData> {
	constructor() {
		super('wirepas.proto.gateway_api.AppConfigData', [
			{
				no: 1,
				name: 'diag_interval_s',
				kind: 'scalar',
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 2,
				name: 'app_config_data',
				kind: 'scalar',
				T: 12 /*ScalarType.BYTES*/,
				options: { nanopb: { maxSize: 1024 } },
			},
			{ no: 3, name: 'seq', kind: 'scalar', T: 13 /*ScalarType.UINT32*/ },
		])
	}
	create(value?: PartialMessage<AppConfigData>): AppConfigData {
		const message = {
			diagIntervalS: 0,
			appConfigData: new Uint8Array(0),
			seq: 0,
		}
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
			enumerable: false,
			value: this,
		})
		if (value !== undefined)
			reflectionMergePartial<AppConfigData>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: AppConfigData,
	): AppConfigData {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* uint32 diag_interval_s */ 1:
					message.diagIntervalS = reader.uint32()
					break
				case /* bytes app_config_data */ 2:
					message.appConfigData = reader.bytes()
					break
				case /* uint32 seq */ 3:
					message.seq = reader.uint32()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d,
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: AppConfigData,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* uint32 diag_interval_s = 1; */
		if (message.diagIntervalS !== 0)
			writer.tag(1, WireType.Varint).uint32(message.diagIntervalS)
		/* bytes app_config_data = 2; */
		if (message.appConfigData.length)
			writer.tag(2, WireType.LengthDelimited).bytes(message.appConfigData)
		/* uint32 seq = 3; */
		if (message.seq !== 0) writer.tag(3, WireType.Varint).uint32(message.seq)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer,
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message wirepas.proto.gateway_api.AppConfigData
 */
export const AppConfigData = new AppConfigData$Type()
// @generated message type with reflection information, may provide speed optimized methods
class NetworkKeys$Type extends MessageType<NetworkKeys> {
	constructor() {
		super('wirepas.proto.gateway_api.NetworkKeys', [
			{
				no: 1,
				name: 'cipher',
				kind: 'scalar',
				T: 12 /*ScalarType.BYTES*/,
				options: { nanopb: { maxSize: 1024 } },
			},
			{
				no: 2,
				name: 'authentication',
				kind: 'scalar',
				T: 12 /*ScalarType.BYTES*/,
				options: { nanopb: { maxSize: 1024 } },
			},
		])
	}
	create(value?: PartialMessage<NetworkKeys>): NetworkKeys {
		const message = {
			cipher: new Uint8Array(0),
			authentication: new Uint8Array(0),
		}
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
			enumerable: false,
			value: this,
		})
		if (value !== undefined)
			reflectionMergePartial<NetworkKeys>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: NetworkKeys,
	): NetworkKeys {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* bytes cipher */ 1:
					message.cipher = reader.bytes()
					break
				case /* bytes authentication */ 2:
					message.authentication = reader.bytes()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d,
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: NetworkKeys,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* bytes cipher = 1; */
		if (message.cipher.length)
			writer.tag(1, WireType.LengthDelimited).bytes(message.cipher)
		/* bytes authentication = 2; */
		if (message.authentication.length)
			writer.tag(2, WireType.LengthDelimited).bytes(message.authentication)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer,
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message wirepas.proto.gateway_api.NetworkKeys
 */
export const NetworkKeys = new NetworkKeys$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SinkReadConfig$Type extends MessageType<SinkReadConfig> {
	constructor() {
		super('wirepas.proto.gateway_api.SinkReadConfig', [
			{
				no: 1,
				name: 'sink_id',
				kind: 'scalar',
				T: 9 /*ScalarType.STRING*/,
				options: { nanopb: { maxSize: 128 } },
			},
			{ no: 2, name: 'node_role', kind: 'message', T: () => NodeRole },
			{
				no: 3,
				name: 'node_address',
				kind: 'scalar',
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 4,
				name: 'network_address',
				kind: 'scalar',
				opt: true,
				T: 4 /*ScalarType.UINT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 5,
				name: 'network_channel',
				kind: 'scalar',
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{ no: 6, name: 'app_config', kind: 'message', T: () => AppConfigData },
			{
				no: 7,
				name: 'channel_map',
				kind: 'scalar',
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 8,
				name: 'are_keys_set',
				kind: 'scalar',
				opt: true,
				T: 8 /*ScalarType.BOOL*/,
			},
			{
				no: 9,
				name: 'current_ac_range',
				kind: 'message',
				T: () => AccessCycleRange,
			},
			{ no: 10, name: 'ac_limits', kind: 'message', T: () => AccessCycleRange },
			{
				no: 11,
				name: 'max_mtu',
				kind: 'scalar',
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 12,
				name: 'channel_limits',
				kind: 'message',
				T: () => ChannelRange,
			},
			{
				no: 13,
				name: 'hw_magic',
				kind: 'scalar',
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 14,
				name: 'stack_profile',
				kind: 'scalar',
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 15,
				name: 'app_config_max_size',
				kind: 'scalar',
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 16,
				name: 'firmware_version',
				kind: 'message',
				T: () => FirmwareVersion,
			},
			{
				no: 17,
				name: 'sink_state',
				kind: 'enum',
				opt: true,
				T: () => ['wirepas.proto.gateway_api.OnOffState', OnOffState],
			},
		])
	}
	create(value?: PartialMessage<SinkReadConfig>): SinkReadConfig {
		const message = { sinkId: '' }
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
			enumerable: false,
			value: this,
		})
		if (value !== undefined)
			reflectionMergePartial<SinkReadConfig>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: SinkReadConfig,
	): SinkReadConfig {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* string sink_id */ 1:
					message.sinkId = reader.string()
					break
				case /* optional wirepas.proto.gateway_api.NodeRole node_role */ 2:
					message.nodeRole = NodeRole.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.nodeRole,
					)
					break
				case /* optional uint32 node_address */ 3:
					message.nodeAddress = reader.uint32()
					break
				case /* optional uint64 network_address */ 4:
					message.networkAddress = reader.uint64().toBigInt()
					break
				case /* optional uint32 network_channel */ 5:
					message.networkChannel = reader.uint32()
					break
				case /* optional wirepas.proto.gateway_api.AppConfigData app_config */ 6:
					message.appConfig = AppConfigData.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.appConfig,
					)
					break
				case /* optional uint32 channel_map */ 7:
					message.channelMap = reader.uint32()
					break
				case /* optional bool are_keys_set */ 8:
					message.areKeysSet = reader.bool()
					break
				case /* optional wirepas.proto.gateway_api.AccessCycleRange current_ac_range */ 9:
					message.currentAcRange = AccessCycleRange.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.currentAcRange,
					)
					break
				case /* optional wirepas.proto.gateway_api.AccessCycleRange ac_limits */ 10:
					message.acLimits = AccessCycleRange.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.acLimits,
					)
					break
				case /* optional uint32 max_mtu */ 11:
					message.maxMtu = reader.uint32()
					break
				case /* optional wirepas.proto.gateway_api.ChannelRange channel_limits */ 12:
					message.channelLimits = ChannelRange.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.channelLimits,
					)
					break
				case /* optional uint32 hw_magic */ 13:
					message.hwMagic = reader.uint32()
					break
				case /* optional uint32 stack_profile */ 14:
					message.stackProfile = reader.uint32()
					break
				case /* optional uint32 app_config_max_size */ 15:
					message.appConfigMaxSize = reader.uint32()
					break
				case /* optional wirepas.proto.gateway_api.FirmwareVersion firmware_version */ 16:
					message.firmwareVersion = FirmwareVersion.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.firmwareVersion,
					)
					break
				case /* optional wirepas.proto.gateway_api.OnOffState sink_state */ 17:
					message.sinkState = reader.int32()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d,
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: SinkReadConfig,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* string sink_id = 1; */
		if (message.sinkId !== '')
			writer.tag(1, WireType.LengthDelimited).string(message.sinkId)
		/* optional wirepas.proto.gateway_api.NodeRole node_role = 2; */
		if (message.nodeRole)
			NodeRole.internalBinaryWrite(
				message.nodeRole,
				writer.tag(2, WireType.LengthDelimited).fork(),
				options,
			).join()
		/* optional uint32 node_address = 3; */
		if (message.nodeAddress !== undefined)
			writer.tag(3, WireType.Varint).uint32(message.nodeAddress)
		/* optional uint64 network_address = 4; */
		if (message.networkAddress !== undefined)
			writer.tag(4, WireType.Varint).uint64(message.networkAddress)
		/* optional uint32 network_channel = 5; */
		if (message.networkChannel !== undefined)
			writer.tag(5, WireType.Varint).uint32(message.networkChannel)
		/* optional wirepas.proto.gateway_api.AppConfigData app_config = 6; */
		if (message.appConfig)
			AppConfigData.internalBinaryWrite(
				message.appConfig,
				writer.tag(6, WireType.LengthDelimited).fork(),
				options,
			).join()
		/* optional uint32 channel_map = 7; */
		if (message.channelMap !== undefined)
			writer.tag(7, WireType.Varint).uint32(message.channelMap)
		/* optional bool are_keys_set = 8; */
		if (message.areKeysSet !== undefined)
			writer.tag(8, WireType.Varint).bool(message.areKeysSet)
		/* optional wirepas.proto.gateway_api.AccessCycleRange current_ac_range = 9; */
		if (message.currentAcRange)
			AccessCycleRange.internalBinaryWrite(
				message.currentAcRange,
				writer.tag(9, WireType.LengthDelimited).fork(),
				options,
			).join()
		/* optional wirepas.proto.gateway_api.AccessCycleRange ac_limits = 10; */
		if (message.acLimits)
			AccessCycleRange.internalBinaryWrite(
				message.acLimits,
				writer.tag(10, WireType.LengthDelimited).fork(),
				options,
			).join()
		/* optional uint32 max_mtu = 11; */
		if (message.maxMtu !== undefined)
			writer.tag(11, WireType.Varint).uint32(message.maxMtu)
		/* optional wirepas.proto.gateway_api.ChannelRange channel_limits = 12; */
		if (message.channelLimits)
			ChannelRange.internalBinaryWrite(
				message.channelLimits,
				writer.tag(12, WireType.LengthDelimited).fork(),
				options,
			).join()
		/* optional uint32 hw_magic = 13; */
		if (message.hwMagic !== undefined)
			writer.tag(13, WireType.Varint).uint32(message.hwMagic)
		/* optional uint32 stack_profile = 14; */
		if (message.stackProfile !== undefined)
			writer.tag(14, WireType.Varint).uint32(message.stackProfile)
		/* optional uint32 app_config_max_size = 15; */
		if (message.appConfigMaxSize !== undefined)
			writer.tag(15, WireType.Varint).uint32(message.appConfigMaxSize)
		/* optional wirepas.proto.gateway_api.FirmwareVersion firmware_version = 16; */
		if (message.firmwareVersion)
			FirmwareVersion.internalBinaryWrite(
				message.firmwareVersion,
				writer.tag(16, WireType.LengthDelimited).fork(),
				options,
			).join()
		/* optional wirepas.proto.gateway_api.OnOffState sink_state = 17; */
		if (message.sinkState !== undefined)
			writer.tag(17, WireType.Varint).int32(message.sinkState)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer,
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message wirepas.proto.gateway_api.SinkReadConfig
 */
export const SinkReadConfig = new SinkReadConfig$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SinkNewConfig$Type extends MessageType<SinkNewConfig> {
	constructor() {
		super('wirepas.proto.gateway_api.SinkNewConfig', [
			{
				no: 1,
				name: 'sink_id',
				kind: 'scalar',
				T: 9 /*ScalarType.STRING*/,
				options: { nanopb: { maxSize: 128 } },
			},
			{ no: 2, name: 'node_role', kind: 'message', T: () => NodeRole },
			{
				no: 3,
				name: 'node_address',
				kind: 'scalar',
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{
				no: 4,
				name: 'network_address',
				kind: 'scalar',
				opt: true,
				T: 4 /*ScalarType.UINT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 5,
				name: 'network_channel',
				kind: 'scalar',
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{ no: 6, name: 'app_config', kind: 'message', T: () => AppConfigData },
			{
				no: 7,
				name: 'channel_map',
				kind: 'scalar',
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
			{ no: 8, name: 'keys', kind: 'message', T: () => NetworkKeys },
			{
				no: 9,
				name: 'current_ac_range',
				kind: 'message',
				T: () => AccessCycleRange,
			},
			{
				no: 10,
				name: 'sink_state',
				kind: 'enum',
				opt: true,
				T: () => ['wirepas.proto.gateway_api.OnOffState', OnOffState],
			},
		])
	}
	create(value?: PartialMessage<SinkNewConfig>): SinkNewConfig {
		const message = { sinkId: '' }
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
			enumerable: false,
			value: this,
		})
		if (value !== undefined)
			reflectionMergePartial<SinkNewConfig>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: SinkNewConfig,
	): SinkNewConfig {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* string sink_id */ 1:
					message.sinkId = reader.string()
					break
				case /* optional wirepas.proto.gateway_api.NodeRole node_role */ 2:
					message.nodeRole = NodeRole.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.nodeRole,
					)
					break
				case /* optional uint32 node_address */ 3:
					message.nodeAddress = reader.uint32()
					break
				case /* optional uint64 network_address */ 4:
					message.networkAddress = reader.uint64().toBigInt()
					break
				case /* optional uint32 network_channel */ 5:
					message.networkChannel = reader.uint32()
					break
				case /* optional wirepas.proto.gateway_api.AppConfigData app_config */ 6:
					message.appConfig = AppConfigData.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.appConfig,
					)
					break
				case /* optional uint32 channel_map */ 7:
					message.channelMap = reader.uint32()
					break
				case /* optional wirepas.proto.gateway_api.NetworkKeys keys */ 8:
					message.keys = NetworkKeys.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.keys,
					)
					break
				case /* optional wirepas.proto.gateway_api.AccessCycleRange current_ac_range */ 9:
					message.currentAcRange = AccessCycleRange.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.currentAcRange,
					)
					break
				case /* optional wirepas.proto.gateway_api.OnOffState sink_state */ 10:
					message.sinkState = reader.int32()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d,
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: SinkNewConfig,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* string sink_id = 1; */
		if (message.sinkId !== '')
			writer.tag(1, WireType.LengthDelimited).string(message.sinkId)
		/* optional wirepas.proto.gateway_api.NodeRole node_role = 2; */
		if (message.nodeRole)
			NodeRole.internalBinaryWrite(
				message.nodeRole,
				writer.tag(2, WireType.LengthDelimited).fork(),
				options,
			).join()
		/* optional uint32 node_address = 3; */
		if (message.nodeAddress !== undefined)
			writer.tag(3, WireType.Varint).uint32(message.nodeAddress)
		/* optional uint64 network_address = 4; */
		if (message.networkAddress !== undefined)
			writer.tag(4, WireType.Varint).uint64(message.networkAddress)
		/* optional uint32 network_channel = 5; */
		if (message.networkChannel !== undefined)
			writer.tag(5, WireType.Varint).uint32(message.networkChannel)
		/* optional wirepas.proto.gateway_api.AppConfigData app_config = 6; */
		if (message.appConfig)
			AppConfigData.internalBinaryWrite(
				message.appConfig,
				writer.tag(6, WireType.LengthDelimited).fork(),
				options,
			).join()
		/* optional uint32 channel_map = 7; */
		if (message.channelMap !== undefined)
			writer.tag(7, WireType.Varint).uint32(message.channelMap)
		/* optional wirepas.proto.gateway_api.NetworkKeys keys = 8; */
		if (message.keys)
			NetworkKeys.internalBinaryWrite(
				message.keys,
				writer.tag(8, WireType.LengthDelimited).fork(),
				options,
			).join()
		/* optional wirepas.proto.gateway_api.AccessCycleRange current_ac_range = 9; */
		if (message.currentAcRange)
			AccessCycleRange.internalBinaryWrite(
				message.currentAcRange,
				writer.tag(9, WireType.LengthDelimited).fork(),
				options,
			).join()
		/* optional wirepas.proto.gateway_api.OnOffState sink_state = 10; */
		if (message.sinkState !== undefined)
			writer.tag(10, WireType.Varint).int32(message.sinkState)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer,
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message wirepas.proto.gateway_api.SinkNewConfig
 */
export const SinkNewConfig = new SinkNewConfig$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GatewayInfo$Type extends MessageType<GatewayInfo> {
	constructor() {
		super('wirepas.proto.gateway_api.GatewayInfo', [
			{
				no: 1,
				name: 'current_time_s_epoch',
				kind: 'scalar',
				T: 4 /*ScalarType.UINT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 2,
				name: 'gw_model',
				kind: 'scalar',
				opt: true,
				T: 9 /*ScalarType.STRING*/,
				options: { nanopb: { maxSize: 256 } },
			},
			{
				no: 3,
				name: 'gw_version',
				kind: 'scalar',
				opt: true,
				T: 9 /*ScalarType.STRING*/,
				options: { nanopb: { maxSize: 128 } },
			},
			{
				no: 4,
				name: 'implemented_api_version',
				kind: 'scalar',
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
		])
	}
	create(value?: PartialMessage<GatewayInfo>): GatewayInfo {
		const message = { currentTimeSEpoch: 0n }
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
			enumerable: false,
			value: this,
		})
		if (value !== undefined)
			reflectionMergePartial<GatewayInfo>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: GatewayInfo,
	): GatewayInfo {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* uint64 current_time_s_epoch */ 1:
					message.currentTimeSEpoch = reader.uint64().toBigInt()
					break
				case /* optional string gw_model */ 2:
					message.gwModel = reader.string()
					break
				case /* optional string gw_version */ 3:
					message.gwVersion = reader.string()
					break
				case /* optional uint32 implemented_api_version */ 4:
					message.implementedApiVersion = reader.uint32()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d,
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: GatewayInfo,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* uint64 current_time_s_epoch = 1; */
		if (message.currentTimeSEpoch !== 0n)
			writer.tag(1, WireType.Varint).uint64(message.currentTimeSEpoch)
		/* optional string gw_model = 2; */
		if (message.gwModel !== undefined)
			writer.tag(2, WireType.LengthDelimited).string(message.gwModel)
		/* optional string gw_version = 3; */
		if (message.gwVersion !== undefined)
			writer.tag(3, WireType.LengthDelimited).string(message.gwVersion)
		/* optional uint32 implemented_api_version = 4; */
		if (message.implementedApiVersion !== undefined)
			writer.tag(4, WireType.Varint).uint32(message.implementedApiVersion)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer,
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message wirepas.proto.gateway_api.GatewayInfo
 */
export const GatewayInfo = new GatewayInfo$Type()
// @generated message type with reflection information, may provide speed optimized methods
class StatusEvent$Type extends MessageType<StatusEvent> {
	constructor() {
		super('wirepas.proto.gateway_api.StatusEvent', [
			{ no: 1, name: 'header', kind: 'message', T: () => EventHeader },
			{ no: 2, name: 'version', kind: 'scalar', T: 13 /*ScalarType.UINT32*/ },
			{
				no: 3,
				name: 'state',
				kind: 'enum',
				T: () => ['wirepas.proto.gateway_api.OnOffState', OnOffState],
			},
		])
	}
	create(value?: PartialMessage<StatusEvent>): StatusEvent {
		const message = { version: 0, state: 0 }
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
			enumerable: false,
			value: this,
		})
		if (value !== undefined)
			reflectionMergePartial<StatusEvent>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: StatusEvent,
	): StatusEvent {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* wirepas.proto.gateway_api.EventHeader header */ 1:
					message.header = EventHeader.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.header,
					)
					break
				case /* uint32 version */ 2:
					message.version = reader.uint32()
					break
				case /* wirepas.proto.gateway_api.OnOffState state */ 3:
					message.state = reader.int32()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d,
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: StatusEvent,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* wirepas.proto.gateway_api.EventHeader header = 1; */
		if (message.header)
			EventHeader.internalBinaryWrite(
				message.header,
				writer.tag(1, WireType.LengthDelimited).fork(),
				options,
			).join()
		/* uint32 version = 2; */
		if (message.version !== 0)
			writer.tag(2, WireType.Varint).uint32(message.version)
		/* wirepas.proto.gateway_api.OnOffState state = 3; */
		if (message.state !== 0) writer.tag(3, WireType.Varint).int32(message.state)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer,
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message wirepas.proto.gateway_api.StatusEvent
 */
export const StatusEvent = new StatusEvent$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GetConfigsReq$Type extends MessageType<GetConfigsReq> {
	constructor() {
		super('wirepas.proto.gateway_api.GetConfigsReq', [
			{ no: 1, name: 'header', kind: 'message', T: () => RequestHeader },
		])
	}
	create(value?: PartialMessage<GetConfigsReq>): GetConfigsReq {
		const message = {}
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
			enumerable: false,
			value: this,
		})
		if (value !== undefined)
			reflectionMergePartial<GetConfigsReq>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: GetConfigsReq,
	): GetConfigsReq {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* wirepas.proto.gateway_api.RequestHeader header */ 1:
					message.header = RequestHeader.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.header,
					)
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d,
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: GetConfigsReq,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* wirepas.proto.gateway_api.RequestHeader header = 1; */
		if (message.header)
			RequestHeader.internalBinaryWrite(
				message.header,
				writer.tag(1, WireType.LengthDelimited).fork(),
				options,
			).join()
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer,
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message wirepas.proto.gateway_api.GetConfigsReq
 */
export const GetConfigsReq = new GetConfigsReq$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GetConfigsResp$Type extends MessageType<GetConfigsResp> {
	constructor() {
		super('wirepas.proto.gateway_api.GetConfigsResp', [
			{ no: 1, name: 'header', kind: 'message', T: () => ResponseHeader },
			{
				no: 2,
				name: 'configs',
				kind: 'message',
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: () => SinkReadConfig,
				options: { nanopb: { maxCount: 16 } },
			},
		])
	}
	create(value?: PartialMessage<GetConfigsResp>): GetConfigsResp {
		const message = { configs: [] }
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
			enumerable: false,
			value: this,
		})
		if (value !== undefined)
			reflectionMergePartial<GetConfigsResp>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: GetConfigsResp,
	): GetConfigsResp {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* wirepas.proto.gateway_api.ResponseHeader header */ 1:
					message.header = ResponseHeader.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.header,
					)
					break
				case /* repeated wirepas.proto.gateway_api.SinkReadConfig configs */ 2:
					message.configs.push(
						SinkReadConfig.internalBinaryRead(reader, reader.uint32(), options),
					)
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d,
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: GetConfigsResp,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* wirepas.proto.gateway_api.ResponseHeader header = 1; */
		if (message.header)
			ResponseHeader.internalBinaryWrite(
				message.header,
				writer.tag(1, WireType.LengthDelimited).fork(),
				options,
			).join()
		/* repeated wirepas.proto.gateway_api.SinkReadConfig configs = 2; */
		for (let i = 0; i < message.configs.length; i++)
			SinkReadConfig.internalBinaryWrite(
				message.configs[i],
				writer.tag(2, WireType.LengthDelimited).fork(),
				options,
			).join()
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer,
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message wirepas.proto.gateway_api.GetConfigsResp
 */
export const GetConfigsResp = new GetConfigsResp$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SetConfigReq$Type extends MessageType<SetConfigReq> {
	constructor() {
		super('wirepas.proto.gateway_api.SetConfigReq', [
			{ no: 1, name: 'header', kind: 'message', T: () => RequestHeader },
			{ no: 2, name: 'config', kind: 'message', T: () => SinkNewConfig },
		])
	}
	create(value?: PartialMessage<SetConfigReq>): SetConfigReq {
		const message = {}
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
			enumerable: false,
			value: this,
		})
		if (value !== undefined)
			reflectionMergePartial<SetConfigReq>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: SetConfigReq,
	): SetConfigReq {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* wirepas.proto.gateway_api.RequestHeader header */ 1:
					message.header = RequestHeader.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.header,
					)
					break
				case /* wirepas.proto.gateway_api.SinkNewConfig config */ 2:
					message.config = SinkNewConfig.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.config,
					)
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d,
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: SetConfigReq,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* wirepas.proto.gateway_api.RequestHeader header = 1; */
		if (message.header)
			RequestHeader.internalBinaryWrite(
				message.header,
				writer.tag(1, WireType.LengthDelimited).fork(),
				options,
			).join()
		/* wirepas.proto.gateway_api.SinkNewConfig config = 2; */
		if (message.config)
			SinkNewConfig.internalBinaryWrite(
				message.config,
				writer.tag(2, WireType.LengthDelimited).fork(),
				options,
			).join()
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer,
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message wirepas.proto.gateway_api.SetConfigReq
 */
export const SetConfigReq = new SetConfigReq$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SetConfigResp$Type extends MessageType<SetConfigResp> {
	constructor() {
		super('wirepas.proto.gateway_api.SetConfigResp', [
			{ no: 1, name: 'header', kind: 'message', T: () => ResponseHeader },
			{ no: 2, name: 'config', kind: 'message', T: () => SinkReadConfig },
		])
	}
	create(value?: PartialMessage<SetConfigResp>): SetConfigResp {
		const message = {}
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
			enumerable: false,
			value: this,
		})
		if (value !== undefined)
			reflectionMergePartial<SetConfigResp>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: SetConfigResp,
	): SetConfigResp {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* wirepas.proto.gateway_api.ResponseHeader header */ 1:
					message.header = ResponseHeader.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.header,
					)
					break
				case /* wirepas.proto.gateway_api.SinkReadConfig config */ 2:
					message.config = SinkReadConfig.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.config,
					)
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d,
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: SetConfigResp,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* wirepas.proto.gateway_api.ResponseHeader header = 1; */
		if (message.header)
			ResponseHeader.internalBinaryWrite(
				message.header,
				writer.tag(1, WireType.LengthDelimited).fork(),
				options,
			).join()
		/* wirepas.proto.gateway_api.SinkReadConfig config = 2; */
		if (message.config)
			SinkReadConfig.internalBinaryWrite(
				message.config,
				writer.tag(2, WireType.LengthDelimited).fork(),
				options,
			).join()
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer,
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message wirepas.proto.gateway_api.SetConfigResp
 */
export const SetConfigResp = new SetConfigResp$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GetGwInfoReq$Type extends MessageType<GetGwInfoReq> {
	constructor() {
		super('wirepas.proto.gateway_api.GetGwInfoReq', [
			{ no: 1, name: 'header', kind: 'message', T: () => RequestHeader },
		])
	}
	create(value?: PartialMessage<GetGwInfoReq>): GetGwInfoReq {
		const message = {}
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
			enumerable: false,
			value: this,
		})
		if (value !== undefined)
			reflectionMergePartial<GetGwInfoReq>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: GetGwInfoReq,
	): GetGwInfoReq {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* wirepas.proto.gateway_api.RequestHeader header */ 1:
					message.header = RequestHeader.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.header,
					)
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d,
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: GetGwInfoReq,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* wirepas.proto.gateway_api.RequestHeader header = 1; */
		if (message.header)
			RequestHeader.internalBinaryWrite(
				message.header,
				writer.tag(1, WireType.LengthDelimited).fork(),
				options,
			).join()
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer,
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message wirepas.proto.gateway_api.GetGwInfoReq
 */
export const GetGwInfoReq = new GetGwInfoReq$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GetGwInfoResp$Type extends MessageType<GetGwInfoResp> {
	constructor() {
		super('wirepas.proto.gateway_api.GetGwInfoResp', [
			{ no: 1, name: 'header', kind: 'message', T: () => ResponseHeader },
			{ no: 2, name: 'info', kind: 'message', T: () => GatewayInfo },
		])
	}
	create(value?: PartialMessage<GetGwInfoResp>): GetGwInfoResp {
		const message = {}
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
			enumerable: false,
			value: this,
		})
		if (value !== undefined)
			reflectionMergePartial<GetGwInfoResp>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: GetGwInfoResp,
	): GetGwInfoResp {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* wirepas.proto.gateway_api.ResponseHeader header */ 1:
					message.header = ResponseHeader.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.header,
					)
					break
				case /* wirepas.proto.gateway_api.GatewayInfo info */ 2:
					message.info = GatewayInfo.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.info,
					)
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d,
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: GetGwInfoResp,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* wirepas.proto.gateway_api.ResponseHeader header = 1; */
		if (message.header)
			ResponseHeader.internalBinaryWrite(
				message.header,
				writer.tag(1, WireType.LengthDelimited).fork(),
				options,
			).join()
		/* wirepas.proto.gateway_api.GatewayInfo info = 2; */
		if (message.info)
			GatewayInfo.internalBinaryWrite(
				message.info,
				writer.tag(2, WireType.LengthDelimited).fork(),
				options,
			).join()
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer,
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message wirepas.proto.gateway_api.GetGwInfoResp
 */
export const GetGwInfoResp = new GetGwInfoResp$Type()
