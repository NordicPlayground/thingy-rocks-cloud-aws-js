/* eslint-disable */
// @generated by protobuf-ts 2.8.2 with parameter ts_nocheck,eslint_disable
// @generated from protobuf file "otap_message.proto" (package "wirepas.proto.gateway_api", syntax proto2)
// tslint:disable
// @ts-nocheck
import type {
	BinaryReadOptions,
	BinaryWriteOptions,
	IBinaryReader,
	IBinaryWriter,
	PartialMessage,
} from '@protobuf-ts/runtime'
import {
	MESSAGE_TYPE,
	MessageType,
	UnknownFieldHandler,
	WireType,
	reflectionMergePartial,
} from '@protobuf-ts/runtime'
import { RequestHeader, ResponseHeader } from './wp_global.js'
/**
 * @generated from protobuf message wirepas.proto.gateway_api.ScratchpadInfo
 */
export interface ScratchpadInfo {
	/**
	 * @generated from protobuf field: uint32 len = 1;
	 */
	len: number
	/**
	 * @generated from protobuf field: uint32 crc = 2;
	 */
	crc: number
	/**
	 * @generated from protobuf field: uint32 seq = 3;
	 */
	seq: number
}
/**
 *
 * Request/Responses definition
 *
 * @generated from protobuf message wirepas.proto.gateway_api.GetScratchpadStatusReq
 */
export interface GetScratchpadStatusReq {
	/**
	 * @generated from protobuf field: wirepas.proto.gateway_api.RequestHeader header = 1;
	 */
	header?: RequestHeader
}
/**
 * @generated from protobuf message wirepas.proto.gateway_api.GetScratchpadStatusResp
 */
export interface GetScratchpadStatusResp {
	/**
	 * @generated from protobuf field: wirepas.proto.gateway_api.ResponseHeader header = 1;
	 */
	header?: ResponseHeader
	/**
	 * @generated from protobuf field: optional wirepas.proto.gateway_api.ScratchpadInfo stored_scratchpad = 2;
	 */
	storedScratchpad?: ScratchpadInfo
	/**
	 * @generated from protobuf field: optional wirepas.proto.gateway_api.ScratchpadStatus stored_status = 3;
	 */
	storedStatus?: ScratchpadStatus
	/**
	 * @generated from protobuf field: optional wirepas.proto.gateway_api.ScratchpadType stored_type = 4;
	 */
	storedType?: ScratchpadType
	/**
	 * @generated from protobuf field: optional wirepas.proto.gateway_api.ScratchpadInfo processed_scratchpad = 5;
	 */
	processedScratchpad?: ScratchpadInfo
	/**
	 * @generated from protobuf field: optional uint32 firmware_area_id = 6;
	 */
	firmwareAreaId?: number
}
/**
 * @generated from protobuf message wirepas.proto.gateway_api.UploadScratchpadReq
 */
export interface UploadScratchpadReq {
	/**
	 * @generated from protobuf field: wirepas.proto.gateway_api.RequestHeader header = 1;
	 */
	header?: RequestHeader
	/**
	 * @generated from protobuf field: uint32 seq = 2;
	 */
	seq: number
	/**
	 * If scratchpad is not set, it clears the stored scratchpad
	 *
	 * @generated from protobuf field: optional bytes scratchpad = 3;
	 */
	scratchpad?: Uint8Array // 1MB
}
/**
 * @generated from protobuf message wirepas.proto.gateway_api.UploadScratchpadResp
 */
export interface UploadScratchpadResp {
	/**
	 * @generated from protobuf field: wirepas.proto.gateway_api.ResponseHeader header = 1;
	 */
	header?: ResponseHeader
}
/**
 * @generated from protobuf message wirepas.proto.gateway_api.ProcessScratchpadReq
 */
export interface ProcessScratchpadReq {
	/**
	 * @generated from protobuf field: wirepas.proto.gateway_api.RequestHeader header = 1;
	 */
	header?: RequestHeader
}
/**
 * @generated from protobuf message wirepas.proto.gateway_api.ProcessScratchpadResp
 */
export interface ProcessScratchpadResp {
	/**
	 * @generated from protobuf field: wirepas.proto.gateway_api.ResponseHeader header = 1;
	 */
	header?: ResponseHeader
}
/**
 * @generated from protobuf enum wirepas.proto.gateway_api.ScratchpadType
 */
export enum ScratchpadType {
	/**
	 * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
	 */
	UNSPECIFIED$ = 0,
	/**
	 * @generated from protobuf enum value: BLANK = 1;
	 */
	BLANK = 1,
	/**
	 * @generated from protobuf enum value: PRESENT = 2;
	 */
	PRESENT = 2,
	/**
	 * @generated from protobuf enum value: PROCESS = 3;
	 */
	PROCESS = 3,
}
/**
 * @generated from protobuf enum wirepas.proto.gateway_api.ScratchpadStatus
 */
export enum ScratchpadStatus {
	/**
	 * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
	 */
	UNSPECIFIED$ = 0,
	/**
	 * @generated from protobuf enum value: SUCCESS = 1;
	 */
	SUCCESS = 1,
	/**
	 * @generated from protobuf enum value: NEW = 2;
	 */
	NEW = 2,
	/**
	 * @generated from protobuf enum value: ERROR = 3;
	 */
	ERROR = 3,
}
// @generated message type with reflection information, may provide speed optimized methods
class ScratchpadInfo$Type extends MessageType<ScratchpadInfo> {
	constructor() {
		super('wirepas.proto.gateway_api.ScratchpadInfo', [
			{ no: 1, name: 'len', kind: 'scalar', T: 13 /*ScalarType.UINT32*/ },
			{ no: 2, name: 'crc', kind: 'scalar', T: 13 /*ScalarType.UINT32*/ },
			{ no: 3, name: 'seq', kind: 'scalar', T: 13 /*ScalarType.UINT32*/ },
		])
	}
	create(value?: PartialMessage<ScratchpadInfo>): ScratchpadInfo {
		const message = { len: 0, crc: 0, seq: 0 }
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
			enumerable: false,
			value: this,
		})
		if (value !== undefined)
			reflectionMergePartial<ScratchpadInfo>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: ScratchpadInfo,
	): ScratchpadInfo {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* uint32 len */ 1:
					message.len = reader.uint32()
					break
				case /* uint32 crc */ 2:
					message.crc = reader.uint32()
					break
				case /* uint32 seq */ 3:
					message.seq = reader.uint32()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d,
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: ScratchpadInfo,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* uint32 len = 1; */
		if (message.len !== 0) writer.tag(1, WireType.Varint).uint32(message.len)
		/* uint32 crc = 2; */
		if (message.crc !== 0) writer.tag(2, WireType.Varint).uint32(message.crc)
		/* uint32 seq = 3; */
		if (message.seq !== 0) writer.tag(3, WireType.Varint).uint32(message.seq)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer,
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message wirepas.proto.gateway_api.ScratchpadInfo
 */
export const ScratchpadInfo = new ScratchpadInfo$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GetScratchpadStatusReq$Type extends MessageType<GetScratchpadStatusReq> {
	constructor() {
		super('wirepas.proto.gateway_api.GetScratchpadStatusReq', [
			{ no: 1, name: 'header', kind: 'message', T: () => RequestHeader },
		])
	}
	create(
		value?: PartialMessage<GetScratchpadStatusReq>,
	): GetScratchpadStatusReq {
		const message = {}
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
			enumerable: false,
			value: this,
		})
		if (value !== undefined)
			reflectionMergePartial<GetScratchpadStatusReq>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: GetScratchpadStatusReq,
	): GetScratchpadStatusReq {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* wirepas.proto.gateway_api.RequestHeader header */ 1:
					message.header = RequestHeader.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.header,
					)
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d,
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: GetScratchpadStatusReq,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* wirepas.proto.gateway_api.RequestHeader header = 1; */
		if (message.header)
			RequestHeader.internalBinaryWrite(
				message.header,
				writer.tag(1, WireType.LengthDelimited).fork(),
				options,
			).join()
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer,
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message wirepas.proto.gateway_api.GetScratchpadStatusReq
 */
export const GetScratchpadStatusReq = new GetScratchpadStatusReq$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GetScratchpadStatusResp$Type extends MessageType<GetScratchpadStatusResp> {
	constructor() {
		super('wirepas.proto.gateway_api.GetScratchpadStatusResp', [
			{ no: 1, name: 'header', kind: 'message', T: () => ResponseHeader },
			{
				no: 2,
				name: 'stored_scratchpad',
				kind: 'message',
				T: () => ScratchpadInfo,
			},
			{
				no: 3,
				name: 'stored_status',
				kind: 'enum',
				opt: true,
				T: () => [
					'wirepas.proto.gateway_api.ScratchpadStatus',
					ScratchpadStatus,
				],
			},
			{
				no: 4,
				name: 'stored_type',
				kind: 'enum',
				opt: true,
				T: () => ['wirepas.proto.gateway_api.ScratchpadType', ScratchpadType],
			},
			{
				no: 5,
				name: 'processed_scratchpad',
				kind: 'message',
				T: () => ScratchpadInfo,
			},
			{
				no: 6,
				name: 'firmware_area_id',
				kind: 'scalar',
				opt: true,
				T: 13 /*ScalarType.UINT32*/,
			},
		])
	}
	create(
		value?: PartialMessage<GetScratchpadStatusResp>,
	): GetScratchpadStatusResp {
		const message = {}
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
			enumerable: false,
			value: this,
		})
		if (value !== undefined)
			reflectionMergePartial<GetScratchpadStatusResp>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: GetScratchpadStatusResp,
	): GetScratchpadStatusResp {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* wirepas.proto.gateway_api.ResponseHeader header */ 1:
					message.header = ResponseHeader.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.header,
					)
					break
				case /* optional wirepas.proto.gateway_api.ScratchpadInfo stored_scratchpad */ 2:
					message.storedScratchpad = ScratchpadInfo.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.storedScratchpad,
					)
					break
				case /* optional wirepas.proto.gateway_api.ScratchpadStatus stored_status */ 3:
					message.storedStatus = reader.int32()
					break
				case /* optional wirepas.proto.gateway_api.ScratchpadType stored_type */ 4:
					message.storedType = reader.int32()
					break
				case /* optional wirepas.proto.gateway_api.ScratchpadInfo processed_scratchpad */ 5:
					message.processedScratchpad = ScratchpadInfo.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.processedScratchpad,
					)
					break
				case /* optional uint32 firmware_area_id */ 6:
					message.firmwareAreaId = reader.uint32()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d,
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: GetScratchpadStatusResp,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* wirepas.proto.gateway_api.ResponseHeader header = 1; */
		if (message.header)
			ResponseHeader.internalBinaryWrite(
				message.header,
				writer.tag(1, WireType.LengthDelimited).fork(),
				options,
			).join()
		/* optional wirepas.proto.gateway_api.ScratchpadInfo stored_scratchpad = 2; */
		if (message.storedScratchpad)
			ScratchpadInfo.internalBinaryWrite(
				message.storedScratchpad,
				writer.tag(2, WireType.LengthDelimited).fork(),
				options,
			).join()
		/* optional wirepas.proto.gateway_api.ScratchpadStatus stored_status = 3; */
		if (message.storedStatus !== undefined)
			writer.tag(3, WireType.Varint).int32(message.storedStatus)
		/* optional wirepas.proto.gateway_api.ScratchpadType stored_type = 4; */
		if (message.storedType !== undefined)
			writer.tag(4, WireType.Varint).int32(message.storedType)
		/* optional wirepas.proto.gateway_api.ScratchpadInfo processed_scratchpad = 5; */
		if (message.processedScratchpad)
			ScratchpadInfo.internalBinaryWrite(
				message.processedScratchpad,
				writer.tag(5, WireType.LengthDelimited).fork(),
				options,
			).join()
		/* optional uint32 firmware_area_id = 6; */
		if (message.firmwareAreaId !== undefined)
			writer.tag(6, WireType.Varint).uint32(message.firmwareAreaId)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer,
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message wirepas.proto.gateway_api.GetScratchpadStatusResp
 */
export const GetScratchpadStatusResp = new GetScratchpadStatusResp$Type()
// @generated message type with reflection information, may provide speed optimized methods
class UploadScratchpadReq$Type extends MessageType<UploadScratchpadReq> {
	constructor() {
		super('wirepas.proto.gateway_api.UploadScratchpadReq', [
			{ no: 1, name: 'header', kind: 'message', T: () => RequestHeader },
			{ no: 2, name: 'seq', kind: 'scalar', T: 13 /*ScalarType.UINT32*/ },
			{
				no: 3,
				name: 'scratchpad',
				kind: 'scalar',
				opt: true,
				T: 12 /*ScalarType.BYTES*/,
				options: { nanopb: { maxSize: 1048576 } },
			},
		])
	}
	create(value?: PartialMessage<UploadScratchpadReq>): UploadScratchpadReq {
		const message = { seq: 0 }
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
			enumerable: false,
			value: this,
		})
		if (value !== undefined)
			reflectionMergePartial<UploadScratchpadReq>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: UploadScratchpadReq,
	): UploadScratchpadReq {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* wirepas.proto.gateway_api.RequestHeader header */ 1:
					message.header = RequestHeader.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.header,
					)
					break
				case /* uint32 seq */ 2:
					message.seq = reader.uint32()
					break
				case /* optional bytes scratchpad */ 3:
					message.scratchpad = reader.bytes()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d,
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: UploadScratchpadReq,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* wirepas.proto.gateway_api.RequestHeader header = 1; */
		if (message.header)
			RequestHeader.internalBinaryWrite(
				message.header,
				writer.tag(1, WireType.LengthDelimited).fork(),
				options,
			).join()
		/* uint32 seq = 2; */
		if (message.seq !== 0) writer.tag(2, WireType.Varint).uint32(message.seq)
		/* optional bytes scratchpad = 3; */
		if (message.scratchpad !== undefined)
			writer.tag(3, WireType.LengthDelimited).bytes(message.scratchpad)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer,
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message wirepas.proto.gateway_api.UploadScratchpadReq
 */
export const UploadScratchpadReq = new UploadScratchpadReq$Type()
// @generated message type with reflection information, may provide speed optimized methods
class UploadScratchpadResp$Type extends MessageType<UploadScratchpadResp> {
	constructor() {
		super('wirepas.proto.gateway_api.UploadScratchpadResp', [
			{ no: 1, name: 'header', kind: 'message', T: () => ResponseHeader },
		])
	}
	create(value?: PartialMessage<UploadScratchpadResp>): UploadScratchpadResp {
		const message = {}
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
			enumerable: false,
			value: this,
		})
		if (value !== undefined)
			reflectionMergePartial<UploadScratchpadResp>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: UploadScratchpadResp,
	): UploadScratchpadResp {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* wirepas.proto.gateway_api.ResponseHeader header */ 1:
					message.header = ResponseHeader.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.header,
					)
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d,
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: UploadScratchpadResp,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* wirepas.proto.gateway_api.ResponseHeader header = 1; */
		if (message.header)
			ResponseHeader.internalBinaryWrite(
				message.header,
				writer.tag(1, WireType.LengthDelimited).fork(),
				options,
			).join()
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer,
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message wirepas.proto.gateway_api.UploadScratchpadResp
 */
export const UploadScratchpadResp = new UploadScratchpadResp$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ProcessScratchpadReq$Type extends MessageType<ProcessScratchpadReq> {
	constructor() {
		super('wirepas.proto.gateway_api.ProcessScratchpadReq', [
			{ no: 1, name: 'header', kind: 'message', T: () => RequestHeader },
		])
	}
	create(value?: PartialMessage<ProcessScratchpadReq>): ProcessScratchpadReq {
		const message = {}
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
			enumerable: false,
			value: this,
		})
		if (value !== undefined)
			reflectionMergePartial<ProcessScratchpadReq>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: ProcessScratchpadReq,
	): ProcessScratchpadReq {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* wirepas.proto.gateway_api.RequestHeader header */ 1:
					message.header = RequestHeader.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.header,
					)
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d,
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: ProcessScratchpadReq,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* wirepas.proto.gateway_api.RequestHeader header = 1; */
		if (message.header)
			RequestHeader.internalBinaryWrite(
				message.header,
				writer.tag(1, WireType.LengthDelimited).fork(),
				options,
			).join()
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer,
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message wirepas.proto.gateway_api.ProcessScratchpadReq
 */
export const ProcessScratchpadReq = new ProcessScratchpadReq$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ProcessScratchpadResp$Type extends MessageType<ProcessScratchpadResp> {
	constructor() {
		super('wirepas.proto.gateway_api.ProcessScratchpadResp', [
			{ no: 1, name: 'header', kind: 'message', T: () => ResponseHeader },
		])
	}
	create(value?: PartialMessage<ProcessScratchpadResp>): ProcessScratchpadResp {
		const message = {}
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
			enumerable: false,
			value: this,
		})
		if (value !== undefined)
			reflectionMergePartial<ProcessScratchpadResp>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: ProcessScratchpadResp,
	): ProcessScratchpadResp {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* wirepas.proto.gateway_api.ResponseHeader header */ 1:
					message.header = ResponseHeader.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.header,
					)
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d,
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: ProcessScratchpadResp,
		writer: IBinaryWriter,
		options: BinaryWriteOptions,
	): IBinaryWriter {
		/* wirepas.proto.gateway_api.ResponseHeader header = 1; */
		if (message.header)
			ResponseHeader.internalBinaryWrite(
				message.header,
				writer.tag(1, WireType.LengthDelimited).fork(),
				options,
			).join()
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer,
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message wirepas.proto.gateway_api.ProcessScratchpadResp
 */
export const ProcessScratchpadResp = new ProcessScratchpadResp$Type()
